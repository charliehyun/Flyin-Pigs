import { HttpHeaders, HttpParams, HttpRequest, HttpResponse } from '@angular/common/http';
import { Injectable, Optional } from '@angular/core';
import { isObservable, of, throwError } from 'rxjs';
import { catchError, concatMap, filter, map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
export class NGXLoggerServerService {
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
    }
    /**
     * Transforms an error object into a readable string (taking only the stack)
     * This is needed because JSON.stringify would return "{}"
     * @param err the error object
     * @returns The stack of the error
     */
    secureErrorObject(err) {
        return err?.stack;
    }
    /**
     * Transforms the additional parameters to avoid any json error when sending the data to the server
     * Basically it just replaces unstringifiable object to a string mentioning an error
     * @param additional The additional data to be sent
     * @returns The additional data secured
     */
    secureAdditionalParameters(additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map((next, idx) => {
            try {
                if (next instanceof Error) {
                    return this.secureErrorObject(next);
                }
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                if (typeof next === 'object') {
                    JSON.stringify(next);
                }
                return next;
            }
            catch (e) {
                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;
            }
        });
    }
    /**
     * Transforms the message so that it can be sent to the server
     * @param message the message to be sent
     * @returns the message secured
     */
    secureMessage(message) {
        try {
            if (message instanceof Error) {
                return this.secureErrorObject(message);
            }
            if (typeof message !== 'string') {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (e) {
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    }
    /**
     * Edits HttpRequest object before sending request to server
     * @param httpRequest default request object
     * @returns altered httprequest
     */
    alterHttpRequest(httpRequest) {
        return httpRequest;
    }
    /**
     * Sends request to server
     * @param url
     * @param logContent
     * @param options
     * @returns
     */
    logOnServer(url, logContent, options) {
        if (!this.httpBackend) {
            console.error('NGXLogger : Can\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');
            return of(null);
        }
        // HttpBackend skips all HttpInterceptors
        // They may log errors using this service causing circular calls
        let defaultRequest = new HttpRequest('POST', url, logContent, options || {});
        let finalRequest = of(defaultRequest);
        const alteredRequest = this.alterHttpRequest(defaultRequest);
        if (isObservable(alteredRequest)) {
            finalRequest = alteredRequest;
        }
        else if (alteredRequest) {
            finalRequest = of(alteredRequest);
        }
        else {
            console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');
        }
        return finalRequest.pipe(concatMap(req => {
            if (!req) {
                console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');
                return this.httpBackend.handle(defaultRequest);
            }
            return this.httpBackend.handle(req);
        }), filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));
    }
    /**
     * Customise the data sent to the API
     * @param metadata the data provided by NGXLogger
     * @returns the data that will be sent to the API in the body
     */
    customiseRequestBody(metadata) {
        // In our API the body is not customised
        return metadata;
    }
    sendToServer(metadata, config) {
        // Copying metadata locally because we don't want to change the object for the caller
        const localMetadata = { ...metadata };
        localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);
        localMetadata.message = this.secureMessage(localMetadata.message);
        // Allow users to customise the data sent to the API
        const requestBody = this.customiseRequestBody(localMetadata);
        const headers = config.customHttpHeaders || new HttpHeaders();
        if (!headers.has('Content-Type')) {
            headers.set('Content-Type', 'application/json');
        }
        this.logOnServer(config.serverLoggingUrl, requestBody, {
            headers,
            params: config.customHttpParams || new HttpParams(),
            responseType: config.httpResponseType || 'json',
            withCredentials: config.withCredentials || false,
        }).pipe(catchError(err => {
            // Do not use NGXLogger here because this could cause an infinite loop 
            console.error('NGXLogger: Failed to log on server', err);
            return throwError(err);
        })).subscribe();
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerServerService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerServerService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerServerService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{
                    type: Optional
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL3NlcnZlci9zZXJ2ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWUsV0FBVyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDdkcsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUFVLFlBQVksRUFBYyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBTXBFLE1BQU0sT0FBTyxzQkFBc0I7SUFFakMsWUFDaUMsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFDckQsQ0FBQztJQUVMOzs7OztPQUtHO0lBQ08saUJBQWlCLENBQUMsR0FBVTtRQUNwQyxPQUFPLEdBQUcsRUFBRSxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sMEJBQTBCLENBQUMsVUFBaUI7UUFDcEQsSUFBSSxVQUFVLEtBQUssSUFBSSxJQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7WUFDbkQsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE9BQU8sVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUNsQyxJQUFJO2dCQUNGLElBQUksSUFBSSxZQUFZLEtBQUssRUFBRTtvQkFDekIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3JDO2dCQUNELCtGQUErRjtnQkFDL0YsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7b0JBQzVCLElBQUksQ0FBQyxTQUFT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SSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFbEUsb0RBQW9EO1FBQ3BELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUU3RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsaUJBQWlCLElBQUksSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUM5RCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FDZCxNQUFNLENBQUMsZ0JBQWdCLEVBQ3ZCLFdBQVcsRUFDWDtZQUNFLE9BQU87WUFDUCxNQUFNLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixJQUFJLElBQUksVUFBVSxFQUFFO1lBQ25ELFlBQVksRUFBRSxNQUFNLENBQUMsZ0JBQWdCLElBQUksTUFBTTtZQUMvQyxlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWUsSUFBSSxLQUFLO1NBQ2pELENBQ0YsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3RCLHVFQUF1RTtZQUN2RSxPQUFPLENBQUMsS0FBSyxDQUFDLG9DQUFvQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3pELE9BQU8sVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDbEIsQ0FBQzs7eUpBdktVLHNCQUFzQjs2SkFBdEIsc0JBQXNCOzJGQUF0QixzQkFBc0I7a0JBRGxDLFVBQVU7OzBCQUlOLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQmFja2VuZCwgSHR0cEhlYWRlcnMsIEh0dHBQYXJhbXMsIEh0dHBSZXF1ZXN0LCBIdHRwUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGNvbmNhdCwgaXNPYnNlcnZhYmxlLCBPYnNlcnZhYmxlLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yLCBjb25jYXRNYXAsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBJTkdYTG9nZ2VyTWV0YWRhdGEgfSBmcm9tICcuLi9tZXRhZGF0YS9pbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBJTkdYTG9nZ2VyQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2ljb25maWcnO1xyXG5pbXBvcnQgeyBJTkdYTG9nZ2VyU2VydmVyU2VydmljZSB9IGZyb20gJy4vaXNlcnZlci5zZXJ2aWNlJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE5HWExvZ2dlclNlcnZlclNlcnZpY2UgaW1wbGVtZW50cyBJTkdYTG9nZ2VyU2VydmVyU2VydmljZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHJlYWRvbmx5IGh0dHBCYWNrZW5kOiBIdHRwQmFja2VuZCxcclxuICApIHsgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIGFuIGVycm9yIG9iamVjdCBpbnRvIGEgcmVhZGFibGUgc3RyaW5nICh0YWtpbmcgb25seSB0aGUgc3RhY2spXHJcbiAgICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBKU09OLnN0cmluZ2lmeSB3b3VsZCByZXR1cm4gXCJ7fVwiXHJcbiAgICogQHBhcmFtIGVyciB0aGUgZXJyb3Igb2JqZWN0XHJcbiAgICogQHJldHVybnMgVGhlIHN0YWNrIG9mIHRoZSBlcnJvclxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBzZWN1cmVFcnJvck9iamVjdChlcnI6IEVycm9yKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBlcnI/LnN0YWNrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyB0aGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGF2b2lkIGFueSBqc29uIGVycm9yIHdoZW4gc2VuZGluZyB0aGUgZGF0YSB0byB0aGUgc2VydmVyXHJcbiAgICogQmFzaWNhbGx5IGl0IGp1c3QgcmVwbGFjZXMgdW5zdHJpbmdpZmlhYmxlIG9iamVjdCB0byBhIHN0cmluZyBtZW50aW9uaW5nIGFuIGVycm9yXHJcbiAgICogQHBhcmFtIGFkZGl0aW9uYWwgVGhlIGFkZGl0aW9uYWwgZGF0YSB0byBiZSBzZW50XHJcbiAgICogQHJldHVybnMgVGhlIGFkZGl0aW9uYWwgZGF0YSBzZWN1cmVkXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHNlY3VyZUFkZGl0aW9uYWxQYXJhbWV0ZXJzKGFkZGl0aW9uYWw6IGFueVtdKTogYW55W10ge1xyXG4gICAgaWYgKGFkZGl0aW9uYWwgPT09IG51bGwgfHwgYWRkaXRpb25hbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhZGRpdGlvbmFsLm1hcCgobmV4dCwgaWR4KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VjdXJlRXJyb3JPYmplY3QobmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUgdGhlIEpTT04gY2FuIGJlIHBhcnNlZCwgd2UgZG8gbm90IHdhbnQgdG8gYWN0dWFsbHkgY2hhbmdlIHRoZSB0eXBlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBgVGhlIGFkZGl0aW9uYWxbJHtpZHh9XSB2YWx1ZSBjb3VsZCBub3QgYmUgcGFyc2VkIHVzaW5nIEpTT04uc3RyaW5naWZ5KCkuYDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIHRoZSBtZXNzYWdlIHNvIHRoYXQgaXQgY2FuIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxyXG4gICAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGJlIHNlbnRcclxuICAgKiBAcmV0dXJucyB0aGUgbWVzc2FnZSBzZWN1cmVkXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHNlY3VyZU1lc3NhZ2UobWVzc2FnZTogYW55KTogc3RyaW5nIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWN1cmVFcnJvck9iamVjdChtZXNzYWdlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBtZXNzYWdlID0gJ1RoZSBwcm92aWRlZCBcIm1lc3NhZ2VcIiB2YWx1ZSBjb3VsZCBub3QgYmUgcGFyc2VkIHdpdGggSlNPTi5zdHJpbmdpZnkoKS4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRWRpdHMgSHR0cFJlcXVlc3Qgb2JqZWN0IGJlZm9yZSBzZW5kaW5nIHJlcXVlc3QgdG8gc2VydmVyXHJcbiAgICogQHBhcmFtIGh0dHBSZXF1ZXN0IGRlZmF1bHQgcmVxdWVzdCBvYmplY3RcclxuICAgKiBAcmV0dXJucyBhbHRlcmVkIGh0dHByZXF1ZXN0XHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGFsdGVySHR0cFJlcXVlc3QoaHR0cFJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBIdHRwUmVxdWVzdDxhbnk+IHwgT2JzZXJ2YWJsZTxIdHRwUmVxdWVzdDxhbnk+PiB7XHJcbiAgICByZXR1cm4gaHR0cFJlcXVlc3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kcyByZXF1ZXN0IHRvIHNlcnZlclxyXG4gICAqIEBwYXJhbSB1cmwgXHJcbiAgICogQHBhcmFtIGxvZ0NvbnRlbnQgXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgXHJcbiAgICogQHJldHVybnMgXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGxvZ09uU2VydmVyKFxyXG4gICAgdXJsOiBzdHJpbmcsXHJcbiAgICBsb2dDb250ZW50OiBhbnksXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgIGhlYWRlcnM/OiBIdHRwSGVhZGVycztcclxuICAgICAgcmVwb3J0UHJvZ3Jlc3M/OiBib29sZWFuO1xyXG4gICAgICBwYXJhbXM/OiBIdHRwUGFyYW1zO1xyXG4gICAgICByZXNwb25zZVR5cGU/OiAnYXJyYXlidWZmZXInIHwgJ2Jsb2InIHwgJ2pzb24nIHwgJ3RleHQnO1xyXG4gICAgICB3aXRoQ3JlZGVudGlhbHM/OiBib29sZWFuO1xyXG4gICAgfSxcclxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xyXG5cclxuICAgIGlmICghdGhpcy5odHRwQmFja2VuZCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdOR1hMb2dnZXIgOiBDYW5cXCd0IGxvZyBvbiBzZXJ2ZXIgYmVjYXVzZSBIdHRwQmFja2VuZCBpcyBub3QgcHJvdmlkZWQuIFlvdSBuZWVkIHRvIGltcG9ydCBIdHRwQ2xpZW50TW9kdWxlJyk7XHJcbiAgICAgIHJldHVybiBvZihudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIdHRwQmFja2VuZCBza2lwcyBhbGwgSHR0cEludGVyY2VwdG9yc1xyXG4gICAgLy8gVGhleSBtYXkgbG9nIGVycm9ycyB1c2luZyB0aGlzIHNlcnZpY2UgY2F1c2luZyBjaXJjdWxhciBjYWxsc1xyXG4gICAgbGV0IGRlZmF1bHRSZXF1ZXN0ID0gbmV3IEh0dHBSZXF1ZXN0PGFueT4oJ1BPU1QnLCB1cmwsIGxvZ0NvbnRlbnQsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgbGV0IGZpbmFsUmVxdWVzdDogT2JzZXJ2YWJsZTxIdHRwUmVxdWVzdDxhbnk+PiA9IG9mKGRlZmF1bHRSZXF1ZXN0KTtcclxuXHJcbiAgICBjb25zdCBhbHRlcmVkUmVxdWVzdCA9IHRoaXMuYWx0ZXJIdHRwUmVxdWVzdChkZWZhdWx0UmVxdWVzdCk7XHJcblxyXG4gICAgaWYgKGlzT2JzZXJ2YWJsZShhbHRlcmVkUmVxdWVzdCkpIHtcclxuICAgICAgZmluYWxSZXF1ZXN0ID0gYWx0ZXJlZFJlcXVlc3Q7XHJcbiAgICB9IGVsc2UgaWYgKGFsdGVyZWRSZXF1ZXN0KSB7XHJcbiAgICAgIGZpbmFsUmVxdWVzdCA9IG9mKGFsdGVyZWRSZXF1ZXN0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignTkdYTG9nZ2VyIDogYWx0ZXJIdHRwUmVxdWVzdCByZXR1cm5lZCBhbiBpbnZhbGlkIHJlcXVlc3QuIFVzaW5nIGRlZmF1bHQgb25lIGluc3RlYWQnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmluYWxSZXF1ZXN0LnBpcGUoXHJcbiAgICAgIGNvbmNhdE1hcChyZXEgPT4ge1xyXG4gICAgICAgIGlmICghcmVxKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ05HWExvZ2dlciA6IGFsdGVySHR0cFJlcXVlc3QgcmV0dXJuZWQgYW4gaW52YWxpZCByZXF1ZXN0IChvYnNlcnZhYmxlKS4gVXNpbmcgZGVmYXVsdCBvbmUgaW5zdGVhZCcpO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuaGFuZGxlKGRlZmF1bHRSZXF1ZXN0KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5oYW5kbGUocmVxKTtcclxuICAgICAgfSksXHJcbiAgICAgIGZpbHRlcihlID0+IGUgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpLFxyXG4gICAgICBtYXA8SHR0cFJlc3BvbnNlPGFueT4sIGFueT4oKGh0dHBSZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4pID0+IGh0dHBSZXNwb25zZS5ib2R5KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEN1c3RvbWlzZSB0aGUgZGF0YSBzZW50IHRvIHRoZSBBUElcclxuICAgKiBAcGFyYW0gbWV0YWRhdGEgdGhlIGRhdGEgcHJvdmlkZWQgYnkgTkdYTG9nZ2VyXHJcbiAgICogQHJldHVybnMgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgYm9keVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjdXN0b21pc2VSZXF1ZXN0Qm9keShtZXRhZGF0YTogSU5HWExvZ2dlck1ldGFkYXRhKTogYW55IHtcclxuICAgIC8vIEluIG91ciBBUEkgdGhlIGJvZHkgaXMgbm90IGN1c3RvbWlzZWRcclxuICAgIHJldHVybiBtZXRhZGF0YTtcclxuICB9XHJcblxyXG5cclxuICBwdWJsaWMgc2VuZFRvU2VydmVyKG1ldGFkYXRhOiBJTkdYTG9nZ2VyTWV0YWRhdGEsIGNvbmZpZzogSU5HWExvZ2dlckNvbmZpZyk6IHZvaWQge1xyXG4gICAgLy8gQ29weWluZyBtZXRhZGF0YSBsb2NhbGx5IGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG9iamVjdCBmb3IgdGhlIGNhbGxlclxyXG4gICAgY29uc3QgbG9jYWxNZXRhZGF0YSA9IHsgLi4ubWV0YWRhdGEgfTtcclxuXHJcbiAgICBsb2NhbE1ldGFkYXRhLmFkZGl0aW9uYWwgPSB0aGlzLnNlY3VyZUFkZGl0aW9uYWxQYXJhbWV0ZXJzKGxvY2FsTWV0YWRhdGEuYWRkaXRpb25hbCk7XHJcblxyXG4gICAgbG9jYWxNZXRhZGF0YS5tZXNzYWdlID0gdGhpcy5zZWN1cmVNZXNzYWdlKGxvY2FsTWV0YWRhdGEubWVzc2FnZSk7XHJcblxyXG4gICAgLy8gQWxsb3cgdXNlcnMgdG8gY3VzdG9taXNlIHRoZSBkYXRhIHNlbnQgdG8gdGhlIEFQSVxyXG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB0aGlzLmN1c3RvbWlzZVJlcXVlc3RCb2R5KGxvY2FsTWV0YWRhdGEpO1xyXG5cclxuICAgIGNvbnN0IGhlYWRlcnMgPSBjb25maWcuY3VzdG9tSHR0cEhlYWRlcnMgfHwgbmV3IEh0dHBIZWFkZXJzKCk7XHJcbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xyXG4gICAgICBoZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvZ09uU2VydmVyKFxyXG4gICAgICBjb25maWcuc2VydmVyTG9nZ2luZ1VybCxcclxuICAgICAgcmVxdWVzdEJvZHksXHJcbiAgICAgIHtcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIHBhcmFtczogY29uZmlnLmN1c3RvbUh0dHBQYXJhbXMgfHwgbmV3IEh0dHBQYXJhbXMoKSxcclxuICAgICAgICByZXNwb25zZVR5cGU6IGNvbmZpZy5odHRwUmVzcG9uc2VUeXBlIHx8ICdqc29uJyxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICApLnBpcGUoY2F0Y2hFcnJvcihlcnIgPT4ge1xyXG4gICAgICAvLyBEbyBub3QgdXNlIE5HWExvZ2dlciBoZXJlIGJlY2F1c2UgdGhpcyBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wIFxyXG4gICAgICBjb25zb2xlLmVycm9yKCdOR1hMb2dnZXI6IEZhaWxlZCB0byBsb2cgb24gc2VydmVyJywgZXJyKTtcclxuICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyKTtcclxuICAgIH0pKS5zdWJzY3JpYmUoKTtcclxuICB9XHJcbn1cclxuIl19