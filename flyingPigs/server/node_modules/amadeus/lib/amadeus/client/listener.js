"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _response = _interopRequireDefault(require("./response"));

var _util = _interopRequireDefault(require("util"));

var _errors = require("./errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Listen to changes in the HTTP request and build Response/ResponseError
 * objects accordingly.
 *
 * @param {Request} request the request object used to make the call
 * @param {EventEmitter} emitter a Node event emitter
 * @param {Client} client the client instance to log results to
 * @protected
 */
var Listener = /*#__PURE__*/function () {
  function Listener(request, emitter, client) {
    _classCallCheck(this, Listener);

    this.request = request;
    this.emitter = emitter;
    this.client = client;
  } // PROTECTED

  /**
   * Listens to various events on the http_response object, listening for data,
   * connections closing for bad reasons, and the end of the response.
   *
   * Used by the Client when making an API call.
   *
   * @param  {Object} http_response a Node http response object
   * @protected
   */


  _createClass(Listener, [{
    key: "onResponse",
    value: function onResponse(http_response) {
      var response = new _response["default"](http_response, this.request);
      http_response.on('data', response.addChunk.bind(response));
      http_response.on('end', this.onEnd(response).bind(this));
      http_response.on('close', this.onNetworkError(response).bind(this));
      http_response.on('error', this.onNetworkError(response).bind(this));
    }
    /**
     * Listens to a network error when making an API call.
     *
     * Used by the Client when making an API call.
     *
     * @param  {Object} http_response a Node http response object
     * @protected
     */

  }, {
    key: "onError",
    value: function onError(http_response) {
      var response = new _response["default"](http_response, this.request);
      this.onNetworkError(response)();
    } // PRIVATE

    /**
     * When the connection ends, check if the response can be parsed or not and
     * act accordingly.
     *
     * @param  {Response} response
     */

  }, {
    key: "onEnd",
    value: function onEnd(response) {
      var _this = this;

      return function () {
        response.parse();

        if (response.success()) {
          _this.onSuccess(response);
        } else {
          _this.onFail(response);
        }
      };
    }
    /**
     * When the response was successful, resolve the promise and return the
     * response object
     *
     * @param  {Response} response
     */

  }, {
    key: "onSuccess",
    value: function onSuccess(response) {
      this.log(response);
      this.emitter.emit('resolve', response);
    }
    /**
     * When the connection was not successful, determine the reason and resolve
     * the promise accordingly.
     *
     * @param  {Response} response
     */

  }, {
    key: "onFail",
    value: function onFail(response) {
      var Error = this.errorFor(response);
      var error = new Error(response);
      this.log(response, error);
      this.emitter.emit('reject', error);
    }
    /**
     * Find the right error for the given response.
     *
     * @param {Response} reponse
     * @returns {ResponseError}
     */

  }, {
    key: "errorFor",
    value: function errorFor(_ref) {
      var statusCode = _ref.statusCode,
          parsed = _ref.parsed;
      var error = null;

      if (statusCode >= 500) {
        error = _errors.ServerError;
      } else if (statusCode == 401) {
        error = _errors.AuthenticationError;
      } else if (statusCode == 404) {
        error = _errors.NotFoundError;
      } else if (statusCode >= 400) {
        error = _errors.ClientError;
      } else if (!parsed) {
        error = _errors.ParserError;
      } else {
        error = _errors.UnknownError;
      }

      return error;
    }
    /**
     * When the connection ran into a network error, reject the promise with a
     * NetworkError.
     *
     * @param  {Response} response
     */

  }, {
    key: "onNetworkError",
    value: function onNetworkError(response) {
      var _this2 = this;

      return function () {
        response.parse();
        var error = new _errors.NetworkError(response);

        _this2.log(response, error);

        _this2.emitter.emit('reject', error);
      };
    }
    /**
     * Logs the response, when in debug mode
     *
     * @param  {Response} response the response object to log
     * @private
     */

  }, {
    key: "log",
    value: function log(response, error) {
      if (this.client.debug()) {
        /* istanbul ignore next */
        this.client.logger.log(_util["default"].inspect(response, false, null));
      }

      if (!this.client.debug() && this.client.warn() && error) {
        /* istanbul ignore next */
        this.client.logger.log('Amadeus', error.code, error.description);
      }
    }
  }]);

  return Listener;
}();

var _default = Listener;
exports["default"] = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJMaXN0ZW5lciIsInJlcXVlc3QiLCJlbWl0dGVyIiwiY2xpZW50IiwiaHR0cF9yZXNwb25zZSIsInJlc3BvbnNlIiwiUmVzcG9uc2UiLCJvbiIsImFkZENodW5rIiwiYmluZCIsIm9uRW5kIiwib25OZXR3b3JrRXJyb3IiLCJwYXJzZSIsInN1Y2Nlc3MiLCJvblN1Y2Nlc3MiLCJvbkZhaWwiLCJsb2ciLCJlbWl0IiwiRXJyb3IiLCJlcnJvckZvciIsImVycm9yIiwic3RhdHVzQ29kZSIsInBhcnNlZCIsIlNlcnZlckVycm9yIiwiQXV0aGVudGljYXRpb25FcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJDbGllbnRFcnJvciIsIlBhcnNlckVycm9yIiwiVW5rbm93bkVycm9yIiwiTmV0d29ya0Vycm9yIiwiZGVidWciLCJsb2dnZXIiLCJ1dGlsIiwiaW5zcGVjdCIsIndhcm4iLCJjb2RlIiwiZGVzY3JpcHRpb24iXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYW1hZGV1cy9jbGllbnQvbGlzdGVuZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlc3BvbnNlIGZyb20gJy4vcmVzcG9uc2UnO1xuaW1wb3J0IHV0aWwgICAgIGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQge1xuICBTZXJ2ZXJFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgQ2xpZW50RXJyb3IsXG4gIFBhcnNlckVycm9yLFxuICBVbmtub3duRXJyb3IsXG4gIE5ldHdvcmtFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvclxufSBmcm9tICcuL2Vycm9ycyc7XG5cblxuLyoqXG4gKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgSFRUUCByZXF1ZXN0IGFuZCBidWlsZCBSZXNwb25zZS9SZXNwb25zZUVycm9yXG4gKiBvYmplY3RzIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdCB0aGUgcmVxdWVzdCBvYmplY3QgdXNlZCB0byBtYWtlIHRoZSBjYWxsXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBhIE5vZGUgZXZlbnQgZW1pdHRlclxuICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCB0aGUgY2xpZW50IGluc3RhbmNlIHRvIGxvZyByZXN1bHRzIHRvXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmNsYXNzIExpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgZW1pdHRlciwgY2xpZW50KSB7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMuY2xpZW50ICA9IGNsaWVudDtcbiAgfVxuXG4gIC8vIFBST1RFQ1RFRFxuXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gdmFyaW91cyBldmVudHMgb24gdGhlIGh0dHBfcmVzcG9uc2Ugb2JqZWN0LCBsaXN0ZW5pbmcgZm9yIGRhdGEsXG4gICAqIGNvbm5lY3Rpb25zIGNsb3NpbmcgZm9yIGJhZCByZWFzb25zLCBhbmQgdGhlIGVuZCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFVzZWQgYnkgdGhlIENsaWVudCB3aGVuIG1ha2luZyBhbiBBUEkgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBodHRwX3Jlc3BvbnNlIGEgTm9kZSBodHRwIHJlc3BvbnNlIG9iamVjdFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBvblJlc3BvbnNlKGh0dHBfcmVzcG9uc2UpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoaHR0cF9yZXNwb25zZSwgdGhpcy5yZXF1ZXN0KTtcblxuICAgIGh0dHBfcmVzcG9uc2Uub24oJ2RhdGEnLCAgcmVzcG9uc2UuYWRkQ2h1bmsuYmluZChyZXNwb25zZSkpO1xuICAgIGh0dHBfcmVzcG9uc2Uub24oJ2VuZCcsICAgdGhpcy5vbkVuZChyZXNwb25zZSkuYmluZCh0aGlzKSk7XG4gICAgaHR0cF9yZXNwb25zZS5vbignY2xvc2UnLCB0aGlzLm9uTmV0d29ya0Vycm9yKHJlc3BvbnNlKS5iaW5kKHRoaXMpKTtcbiAgICBodHRwX3Jlc3BvbnNlLm9uKCdlcnJvcicsIHRoaXMub25OZXR3b3JrRXJyb3IocmVzcG9uc2UpLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gYSBuZXR3b3JrIGVycm9yIHdoZW4gbWFraW5nIGFuIEFQSSBjYWxsLlxuICAgKlxuICAgKiBVc2VkIGJ5IHRoZSBDbGllbnQgd2hlbiBtYWtpbmcgYW4gQVBJIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gaHR0cF9yZXNwb25zZSBhIE5vZGUgaHR0cCByZXNwb25zZSBvYmplY3RcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuICBvbkVycm9yKGh0dHBfcmVzcG9uc2UpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoaHR0cF9yZXNwb25zZSwgdGhpcy5yZXF1ZXN0KTtcbiAgICB0aGlzLm9uTmV0d29ya0Vycm9yKHJlc3BvbnNlKSgpO1xuICB9XG5cbiAgLy8gUFJJVkFURVxuXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gZW5kcywgY2hlY2sgaWYgdGhlIHJlc3BvbnNlIGNhbiBiZSBwYXJzZWQgb3Igbm90IGFuZFxuICAgKiBhY3QgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSAge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgb25FbmQocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVzcG9uc2UucGFyc2UoKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKCkpIHsgdGhpcy5vblN1Y2Nlc3MocmVzcG9uc2UpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5vbkZhaWwocmVzcG9uc2UpOyAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwsIHJlc29sdmUgdGhlIHByb21pc2UgYW5kIHJldHVybiB0aGVcbiAgICogcmVzcG9uc2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSAge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgb25TdWNjZXNzKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5sb2cocmVzcG9uc2UpO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KCdyZXNvbHZlJywgcmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gd2FzIG5vdCBzdWNjZXNzZnVsLCBkZXRlcm1pbmUgdGhlIHJlYXNvbiBhbmQgcmVzb2x2ZVxuICAgKiB0aGUgcHJvbWlzZSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtICB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBvbkZhaWwocmVzcG9uc2UpIHtcbiAgICBsZXQgRXJyb3IgPSB0aGlzLmVycm9yRm9yKHJlc3BvbnNlKTtcbiAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2UpO1xuICAgIHRoaXMubG9nKHJlc3BvbnNlLCBlcnJvcik7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoJ3JlamVjdCcsIGVycm9yKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHJpZ2h0IGVycm9yIGZvciB0aGUgZ2l2ZW4gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlcG9uc2VcbiAgICogQHJldHVybnMge1Jlc3BvbnNlRXJyb3J9XG4gICAqL1xuICBlcnJvckZvcih7c3RhdHVzQ29kZSwgcGFyc2VkfSkge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgaWYgKHN0YXR1c0NvZGUgPj0gNTAwKSB7IGVycm9yID0gU2VydmVyRXJyb3I7IH1cbiAgICBlbHNlIGlmIChzdGF0dXNDb2RlID09IDQwMSkgeyBlcnJvciA9IEF1dGhlbnRpY2F0aW9uRXJyb3I7IH1cbiAgICBlbHNlIGlmIChzdGF0dXNDb2RlID09IDQwNCkgeyBlcnJvciA9IE5vdEZvdW5kRXJyb3I7IH1cbiAgICBlbHNlIGlmIChzdGF0dXNDb2RlID49IDQwMCkgeyBlcnJvciA9IENsaWVudEVycm9yOyB9XG4gICAgZWxzZSBpZiAoIXBhcnNlZCkgeyBlcnJvciA9IFBhcnNlckVycm9yOyB9XG4gICAgZWxzZSB7IGVycm9yID0gVW5rbm93bkVycm9yOyB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gcmFuIGludG8gYSBuZXR3b3JrIGVycm9yLCByZWplY3QgdGhlIHByb21pc2Ugd2l0aCBhXG4gICAqIE5ldHdvcmtFcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBvbk5ldHdvcmtFcnJvcihyZXNwb25zZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNwb25zZS5wYXJzZSgpO1xuICAgICAgbGV0IGVycm9yID0gbmV3IE5ldHdvcmtFcnJvcihyZXNwb25zZSk7XG4gICAgICB0aGlzLmxvZyhyZXNwb25zZSwgZXJyb3IpO1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoJ3JlamVjdCcsIGVycm9yKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgdGhlIHJlc3BvbnNlLCB3aGVuIGluIGRlYnVnIG1vZGVcbiAgICpcbiAgICogQHBhcmFtICB7UmVzcG9uc2V9IHJlc3BvbnNlIHRoZSByZXNwb25zZSBvYmplY3QgdG8gbG9nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsb2cocmVzcG9uc2UsIGVycm9yKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50LmRlYnVnKCkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aGlzLmNsaWVudC5sb2dnZXIubG9nKHV0aWwuaW5zcGVjdChyZXNwb25zZSwgZmFsc2UsIG51bGwpKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudC5kZWJ1ZygpICYmIHRoaXMuY2xpZW50Lndhcm4oKSAmJiBlcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5sb2coJ0FtYWRldXMnLCBlcnJvci5jb2RlLCBlcnJvci5kZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RlbmVyO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDTUEsUTtFQUNKLGtCQUFZQyxPQUFaLEVBQXFCQyxPQUFyQixFQUE4QkMsTUFBOUIsRUFBc0M7SUFBQTs7SUFDcEMsS0FBS0YsT0FBTCxHQUFlQSxPQUFmO0lBQ0EsS0FBS0MsT0FBTCxHQUFlQSxPQUFmO0lBQ0EsS0FBS0MsTUFBTCxHQUFlQSxNQUFmO0VBQ0QsQyxDQUVEOztFQUdBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7V0FDRSxvQkFBV0MsYUFBWCxFQUEwQjtNQUN4QixJQUFJQyxRQUFRLEdBQUcsSUFBSUMsb0JBQUosQ0FBYUYsYUFBYixFQUE0QixLQUFLSCxPQUFqQyxDQUFmO01BRUFHLGFBQWEsQ0FBQ0csRUFBZCxDQUFpQixNQUFqQixFQUEwQkYsUUFBUSxDQUFDRyxRQUFULENBQWtCQyxJQUFsQixDQUF1QkosUUFBdkIsQ0FBMUI7TUFDQUQsYUFBYSxDQUFDRyxFQUFkLENBQWlCLEtBQWpCLEVBQTBCLEtBQUtHLEtBQUwsQ0FBV0wsUUFBWCxFQUFxQkksSUFBckIsQ0FBMEIsSUFBMUIsQ0FBMUI7TUFDQUwsYUFBYSxDQUFDRyxFQUFkLENBQWlCLE9BQWpCLEVBQTBCLEtBQUtJLGNBQUwsQ0FBb0JOLFFBQXBCLEVBQThCSSxJQUE5QixDQUFtQyxJQUFuQyxDQUExQjtNQUNBTCxhQUFhLENBQUNHLEVBQWQsQ0FBaUIsT0FBakIsRUFBMEIsS0FBS0ksY0FBTCxDQUFvQk4sUUFBcEIsRUFBOEJJLElBQTlCLENBQW1DLElBQW5D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